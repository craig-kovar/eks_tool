#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.25.1
#  in conjunction with Tcl version 8.6
#    Oct 29, 2019 10:23:58 AM CDT  platform: Darwin

import sys

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

from lib.UI.bucket import BucketTopLevel as CBBucket
from lib.UI.server import ServerTopLevel as CBServer
import lib.utils.ekstool_utils as utils
import lib.utils.kube_utils as kube_utils
from shutil import copyfile

def set_Tk_var():
    global versionbox
    versionbox = tk.StringVar()
    global aa_btn
    aa_btn = tk.IntVar()
    global aacheck
    aacheck = tk.StringVar()
    global bktcheck
    bktcheck = tk.StringVar()
    global tlscheck
    tlscheck = tk.StringVar()
    global bucket_btn
    bucket_btn = tk.IntVar()
    global admincheck
    admincheck = tk.StringVar()
    global adminbox
    adminbox = tk.StringVar()
    global idxbox
    idxbox = tk.StringVar()
    global tls_btn
    tls_btn = tk.IntVar()
    global svc_admin
    svc_admin = tk.IntVar()
    global ext_dns
    ext_dns = tk.IntVar()
    global adm_check
    adm_check = tk.IntVar()
    global svc_xdcr
    svc_xdcr = tk.IntVar()
    global svc_client
    svc_client = tk.IntVar()


def add_bucket():
    #print('kube_config_support.add_bucket')
    #sys.stdout.flush()
    bucket = CBBucket(root, None).show()
    kube_config = w.cb_config.get_cbcluster_config()
    kube_config.add_bucket(bucket)
    update_bucket_display()


def del_bucket():
    #print('kube_config_support.del_bucket')
    #sys.stdout.flush()
    kube_config = w.cb_config.get_cbcluster_config()
    try:
        bucket_name = w.Scrolledlistbox_Buckets.get(w.Scrolledlistbox_Buckets.curselection(), w.Scrolledlistbox_Buckets.curselection())[0]
        name = bucket_name.split(";")[0].split(" ")[1]
        kube_config.del_bucket(name)
        update_bucket_display()
    except tk.TclError:
        pass

def update_bucket_display():
    kube_config = w.cb_config.get_cbcluster_config()
    w.Scrolledlistbox_Buckets.delete(0, 'end')
    buckets = kube_config.buckets
    for itr in buckets:
        item = buckets[itr]
        w.Scrolledlistbox_Buckets.insert('end',
                                       "Name: {0}; Type: {1}; Quota: {2}; Replicas: {3}; ioPriority: {4}; eviction: {5}; conflictResolution: {6}; flush: {7}".format(
                                           item.name, item.type, item.memoryQuota,
                                           item.replicas, item.ioPriority,
                                           item.evictionPolicy, item.conflictResolution,
                                           item.enableFlush
                                       ))


def add_server():
    #print('kube_config_support.add_server')
    #sys.stdout.flush()
    server = CBServer(root, None, w.cb_config.get_cbcluster_config()).show()
    kube_config = w.cb_config.get_cbcluster_config()
    kube_config.add_server(server)
    update_server_display()


def update_server_display():
    kube_config = w.cb_config.get_cbcluster_config()
    w.Scrolledlistbox_Servers.delete(0, 'end')
    servers = kube_config.servers
    for itr in servers:
        item = servers[itr]
        w.Scrolledlistbox_Servers.insert('end',
                                         "Name: {0}; Size: {1}; Services: {2}".format(item.name, item.size,
                                                                                      item.services))


def build_cluster(cb_config):
    #Update kubernetes config with settings
    #w.cb_config.get_cbcluster_config().namespace = w.TEntry_NS.get()
    #w.cb_config.get_cbcluster_config().clustername = w.TEntry_Cluster.get()
    #w.cb_config.get_cbcluster_config().version = versionbox
    #w.cb_config.

    update_config(cb_config)

    kube_utils.build_resource_with_yaml("./resources/cbao/{0}/io1.yaml".format(kube_utils.version))

    utils.check_dir(w.cb_config.name, "kube")
    kube_utils.build_ns("./work/{0}/kube".format(w.cb_config.name), w.cb_config.get_cbcluster_config().namespace)

    kube_utils.setup_tls(cb_config)

    kube_utils.deploy_crd()
    kube_utils.deploy_operator_role(w.cb_config.get_cbcluster_config().namespace)
    kube_utils.deploy_operator_sa(w.cb_config.get_cbcluster_config().namespace)
    kube_utils.build_operator_role_binding("./work/{0}/kube".format(w.cb_config.name),
                                           w.cb_config.get_cbcluster_config().namespace)
    kube_utils.deploy_operator(w.cb_config.get_cbcluster_config().namespace)
    kube_utils.deploy_secret(w.cb_config.get_cbcluster_config().namespace)

    kube_utils.build_cb_cluster("./work/{0}/kube".format(w.cb_config.name), cb_config.get_cbcluster_config())

    kube_utils.build_resource_with_yaml("./work/{0}/kube/couchbase-cluster.yaml --namespace {1}".format(
        w.cb_config.name, w.cb_config.get_cbcluster_config().namespace
    ))

    running = kube_utils.check_cluster_running(cb_config.get_cbcluster_config())

    if not running:
        utils.on_error("Couchbase Cluster is not running")
        return

    # App Servers
    for i in range(0, int(w.cb_config.get_cbcluster_config().app)):
        kube_utils.build_custom_pod("./work/{0}/kube".format(w.cb_config.name),
                                    cb_config.get_cbcluster_config(),
                                    "couchbase-{0}".format(i),
                                    "couchbase/server:enterprise-{0}".format(w.cb_config.get_cbcluster_config().version))

        kube_utils.build_resource_yaml_no_check("./work/{0}/kube/app-pod.yaml --namespace {1}".format(
            w.cb_config.name, w.cb_config.get_cbcluster_config().namespace))

    # Couchmart
    for i in range(0, int(w.cb_config.get_cbcluster_config().couchmart)):
        kube_utils.build_custom_pod("./work/{0}/kube".format(w.cb_config.name),
                                    cb_config.get_cbcluster_config(),
                                    "couchmart-{0}".format(i),
                                    "cbck/couchmart:python2")

        kube_utils.build_resource_yaml_no_check("./work/{0}/kube/app-pod.yaml --namespace {1}".format(
            w.cb_config.name, w.cb_config.get_cbcluster_config().namespace))

        #kube_utils.build_resource_yaml_no_check("./resources/cbao/{0}/couchmart.yaml --namespace {1}".format(
        #    kube_utils.version, w.cb_config.get_cbcluster_config().namespace
        #))

    # SGW
    try:
        sgw_conf = w.cb_config.get_cbcluster_config().sgw_conf
    except AttributeError:
        sgw_conf = None


    if sgw_conf is not None:
        utils.write_line("\nCreating sync gateway with conf: {}".format(sgw_conf))
        utils.execute_command("kubectl create secret generic sgw-config --from-file {0} --namespace {1}".format(
            sgw_conf, w.cb_config.get_cbcluster_config().namespace),
            False)
        copyfile("./resources/cbao/{0}/sgw-deployment.yaml".format(kube_utils.version),
                 "./work/{0}/kube/sgw-deployment.yaml".format(w.cb_config.name))
        utils.execute_command("sed -i -e s/###replica###/{0}/g ./work/{1}/kube/sgw-deployment.yaml".format(
            str(int(w.cb_config.get_cbcluster_config().sgw)), w.cb_config.name
        ), False)

        cffile_array = sgw_conf.split("/")
        cffile = cffile_array[len(cffile_array)-1]

        print("File = {}".format(cffile))
        utils.execute_command("sed -i -e s/###conffile###/{0}/g ./work/{1}/kube/sgw-deployment.yaml".format(
            cffile, w.cb_config.name
        ), False)

        kube_utils.build_resource_with_yaml(
            "./work/{0}/kube/sgw-deployment.yaml --namespace {1}".format(
                w.cb_config.name, w.cb_config.get_cbcluster_config().namespace))
    else:
        for i in range(0, min(int(w.cb_config.get_cbcluster_config().sgw), 2)):
            if i == 0:
                kube_utils.build_sgw_config("./work/{0}/kube".format(
                    w.cb_config.name), w.cb_config.get_cbcluster_config(), True)
                utils.execute_command("kubectl create secret generic sgw-config-import --from-file {0} --namespace {1}".format(
                    "./work/{0}/kube/sgw-config.json".format(w.cb_config.name), w.cb_config.get_cbcluster_config().namespace), False)
                kube_utils.build_resource_with_yaml("./resources/cbao/{0}/sgw-deployment-import.yaml --namespace {1}".format(
                    kube_utils.version, w.cb_config.get_cbcluster_config().namespace))
            else:  #Build non-import SGW using replicas
                kube_utils.build_sgw_config("./work/{0}/kube".format(
                    w.cb_config.name), w.cb_config.get_cbcluster_config(), False)
                utils.execute_command("kubectl create secret generic sgw-config --from-file {0} --namespace {1}".format(
                    "./work/{0}/kube/sgw-config.json".format(w.cb_config.name), w.cb_config.get_cbcluster_config().namespace),
                    False)
                copyfile("./resources/cbao/{0}/sgw-deployment.yaml".format(kube_utils.version),
                        "./work/{0}/kube/sgw-deployment.yaml".format(w.cb_config.name))
                utils.execute_command("sed -i s/###replica###/{0}/g ./work/{1}/kube/sgw-deployment.yaml".format(
                    str(int(w.cb_config.get_cbcluster_config().sgw)-1), w.cb_config.name
                ), False)
                utils.execute_command("sed -i s/###conffile###/{0}/g ./work/{1}/kube/sgw-deployment.yaml".format(
                    "sgw-deployment.yaml"
                ), False)
                kube_utils.build_resource_with_yaml(
                    "./work/{0}/kube/sgw-deployment.yaml --namespace {1}".format(
                        w.cb_config.name, w.cb_config.get_cbcluster_config().namespace))

    utils.write_line("Build of Couchbase Cluster is complete")


def del_server():
    #print('kube_config_support.del_server')
    #sys.stdout.flush()
    kube_config = w.cb_config.get_cbcluster_config()
    try:
        server_name = w.Scrolledlistbox_Servers.get(w.Scrolledlistbox_Servers.curselection(),
                                                    w.Scrolledlistbox_Servers.curselection())[0]
        name = server_name.split(";")[0].split(" ")[1]
        kube_config.del_server(name)
        update_server_display()
    except tk.TclError:
        pass


def edit_server():
    #print('kube_config_support.edit_server')
    #sys.stdout.flush()
    kube_config = w.cb_config.get_cbcluster_config()
    try:
        server_name = w.Scrolledlistbox_Servers.get(w.Scrolledlistbox_Servers.curselection(),
                                                    w.Scrolledlistbox_Servers.curselection())[0]
        name = server_name.split(";")[0].split(" ")[1]
        server = CBServer(root, w.cb_config.get_cbcluster_config().servers[name], w.cb_config.get_cbcluster_config()).show()
        kube_config.add_server(server)
        update_server_display()
    except tk.TclError:
        pass


def update_config(cb_config):
    cb_config.cbcluster_config.namespace = w.TEntry_NS.get()
    cb_config.cbcluster_config.clustername = w.TEntry_Cluster.get()
    cb_config.cbcluster_config.version_loc = w.TCombobox_Version.current()
    cb_config.cbcluster_config.version = w.TCombobox_Version.get()
    if aa_btn.get() == 1:
        cb_config.cbcluster_config.antiaffinity = True
    else:
        cb_config.cbcluster_config.antiaffinity = False

    if bucket_btn.get() == 1:
        cb_config.cbcluster_config.disable_bucket_management = False
    else:
        cb_config.cbcluster_config.disable_bucket_management = True

    cb_config.cbcluster_config.sgw = w.TEntry_SGW.get()
    cb_config.cbcluster_config.app = w.TEntry_App_Server.get()
    cb_config.cbcluster_config.couchmart = w.TEntry_Couchmart.get()

    if tls_btn.get() == 1:
        cb_config.cbcluster_config.tls = True
    else:
        cb_config.cbcluster_config.tls = False

    cb_config.cbcluster_config.expose_features['admin'] = svc_admin.get()

    if ext_dns.get() == 1:
        cb_config.cbcluster_config.external_dns = True
    else:
        cb_config.cbcluster_config.external_dns = False

    if adm_check.get() == 1:
        cb_config.cbcluster_config.expose_admin_console = True
    else:
        cb_config.cbcluster_config.expose_admin_console = False

    cb_config.cbcluster_config.expose_admin_svc_loc = w.TCombobox_AdmSvc.current()
    cb_config.cbcluster_config.expose_admin_svcs = w.TCombobox_AdmSvc.get()
    cb_config.cbcluster_config.expose_features['xdcr'] = svc_xdcr.get()
    cb_config.cbcluster_config.expose_features['client'] = svc_client.get()
    cb_config.cbcluster_config.dns = w.TEntry_DNS.get()

    cb_config.cbcluster_config.cluster['dataServiceMemoryQuota'] = w.TEntry_Data.get()
    cb_config.cbcluster_config.cluster['indexServiceMemoryQuota'] = w.TEntry_Index.get()
    cb_config.cbcluster_config.cluster['searchServiceMemoryQuota'] = w.TEntry_Search.get()
    cb_config.cbcluster_config.cluster['eventingServiceMemoryQuota'] = w.TEntry_Eventing.get()
    cb_config.cbcluster_config.cluster['analyticsServiceMemoryQuota'] = w.TEntry_Analytics.get()

    cb_config.cbcluster_config.idx_loc = w.TCombobox_Index_Store.current()
    cb_config.cbcluster_config.cluster['indexStorageSetting'] = w.TCombobox_Index_Store.get()

    cb_config.cbcluster_config.cluster['autoFailoverTimeout'] = w.TEntry_AF_Time.get()
    cb_config.cbcluster_config.cluster['autoFailoverMaxCount'] = w.TEntry_AF_events.get()


def load_sgw():
    cbcluster_config = w.cb_config.get_cbcluster_config()
    files = [('json', '*.json')]
    # file = asksaveasfile(filetypes=files, defaultextension=files)
    options = {}
    options['defaultextension'] = "json"
    options['filetypes'] = files

    if py3:
        from tkinter import filedialog
        file = filedialog.askopenfile(mode='w', **options)
    else:
        import tkFileDialog
        file = tkFileDialog.askopenfilename(initialdir="/",
                                            title="Select file",
                                            filetypes=files)

    cbcluster_config.sgw_conf = file



def on_cancel(cb_config):
    #print('kube_config_support.on_cancel')
    #sys.stdout.flush()

    update_config(cb_config)
    import lib.UI.MainScreen as MainScreen
    destroy_window()
    MainScreen.vp_start_gui(cb_config)


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


if __name__ == '__main__':
    import kube_config
    kube_config.vp_start_gui()




